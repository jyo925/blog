스프링부트 + jpa + jsp 블로그 만들기
만들면서 학습한 내용 추후 정리하기 위해 메모

** HTTP 요청 **

** Maven이란? **

** jsp를 사용하기 **
1. jasper 의존성 추가
2. yml에서 뷰 경로 설정
3. resources/static이 아닌 webapp/WEB-INF/views 폴더 생성하여 여기에 jsp파일 저장

**  Json 왜? 어떻게? 사용하는가 **
Java에서 Python으로 데이터를 주고 받을 수는 없다.
공용어 Json을 사용해서 해결
전송시 -> 자신의 언어를 Json으로 번역
응답시 -> Json을 자신의 언어로 번역
Json은 중간데이터 역할
통신할 때 자바오브젝트를 Json으로 바꾼 다는 것은 전송을 한다는 것
HTML에 데이터를 Json으로 변경해서 Java로 전송하고, Java에서는 Json 데이터를 Java Object로 변경해서 받으면 됨
-> 컨트롤러에서 req 요청이 올 때 Body 데이터를 Json으로 받을 거임 (MIME타입이 JSON)
-> 컨트롤러에서 res 할 때 Java Object를 Json으로 변경해서 응답


dummyControllerTest detail() 에서
추후 Spring aop를 이용해서 Exception을 가로채서 에러페이지를 보여주기

** MessageConverter **
무슨 역할을, 언제 작동하는지

** 영속성 컨텍스트 **
영속화: 1차 캐시에 객체가 들어간 상태
flush: 영속화된 객체를 DB에 넣는 것, 1차 캐시를 비우지 않음
컨트롤러의 메서드 위의 @Transactional를 사용하면 메서드 종료 직전에 commit 실행
    -> 객체를 영속화 시킨 후 값을 변경하면 트랜잭션 종료 시점에 변경을 감지함
    -> 즉, 1차 캐시에 있는 객체에 변경이 있는지 체크하고 DB에 update 수행(더티 채킹)


** Ajax를 사용하는 이유 2가지 **
1. 요청에 대한 응답을 html이 아닌 json data를 받음으로써 서버를 하나로 사용할 수 있다.
    -> html은 웹 브라우저(클라이언트)가 이해할 수 있는 파일이다. 그러나 클라이언트가 항상 브라우저는 아니다.
    -> 클라이언트는 웹과 앱 2종류가 있는데, 일반적으로 웹은 서버로부터 html를 응답 받고 앱은 json 데이터를 응답 받는다.
    -> 응답이 다르면 서버를 두개 만들어야 하나? X
    -> json data를 리턴하는 서버만 만들어서 사용 -> ajax 통신 등장, 대신 웹 클라이언트는 추가 작업(재요청) 필요
웹에서 동작과정
브라우저가 회원가입 처리 요청 -> 서버가 작업후 data를 리턴 -> 브라우저가 재요청(메인페이지)

2. 비동기 통신
순서에 상관없이 실행하는 것


Service가 필요한 이유
1. 트랜잭션 관리
2. 서비스 의미 때문
- 한 개 이상의 트랜잭션을 하나로 묶어서 서비스화 시킬 수 있기 때문에 이용
- 전체가 성공하면 commit, 실패하면 rollback 처리 @Transactional


** DB 격리수준 **
트랜잭션: 일이 처리되기 위한 가장 작은 단위
여러개의 트랜잭션이 모여서 하나의 트랜잭션이 될 수 있다.
예를 들어 유튜브 1강을 만들기 위해 1.강의 준비(T1) 2. 영상 찍기(T2) 3. 영상 업로드(T3)을 모아서 하나의 트랜잭션으로
처리할 수 있으며, 스프링에서는 service라고 한다.

DB 격리수준이란?
오라클의 경우 Read Commit 전략이 기본
-> 즉 한 트랜잭션에서 데이터를 수정하고 커밋을 하지 않으면, 다른 트랜잭션에서 동일한 데이터를 요청할 때 수정 전 데이터로 읽어들임
    수정, 삭제 등 데이터 변경에 관한 요청이 DB에 들어오면 DB에 있는 undo영역의 데이터(수정 전 데이터)를 읽는다.
    커밋을 실행할 때 수정한 내역이 undo 영역에도 반영된다.
문제점은 중간에 다른 트랜잭션이 끼어들어서 데이터의 정합성을 보장할 수 없다.
이때 데이터가 보였다 안보였다 하는 것을(데이터가 읽을 때, select 할 때 마다 달라지는 것) Phantom Read 라고 한다.
이러한 문제를 해결하려면 repeatable read 이상 방식을 사용하면 부정합이 발생 X
http://wiki.gurubee.net/pages/viewpage.action?pageId=3900389 참고
MySQL
    -> InnoDB 스토리지 엔진
    -> Repeatable Read 방식 사용, 중간에 다른 트랜잭션이 수정하고 커밋하더라도 내가 처음에 읽어온 데이터 그대로 읽어온다.
        -> select시 자신보다 먼저 발생한 트랜잭션의 undo로그를 보고 select 수행
        -> 그래서 select도 트랜잭션이 필요하다. 동일한 데이터를 보장하기 때문
        -> 스프링에서는 @Transactional 지원, select도 되도록 붙이는 것을 추천


** 스프링의 전통적인 트랜잭션 **
요청 발생
1. DB 연결 생성
2. 트랜잭션 시작
컨트롤러 요청 분기 -> 서비스 -> 레파지토리 -> DB -> 레파지토리 -> 서비스
-> 컨트롤러로 돌아오면 3. 트랜잭션 종료
4. 변경감지 DB에 flush
5. DB 연결 세션 종료
응답

전통적인 방식의 문제점:

