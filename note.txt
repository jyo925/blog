스프링부트 + jpa + jsp 블로그 만들기
만들면서 학습한 내용 추후 정리하기 위해 메모

<추가 기능 구현>
수정, 삭제 다른 아이디로 우회해서 처리 되는지 안되는지 된다면 막아주기



** HTTP 요청 **
stateless: 요청 시 마다 스트림을 연결해서 데이터를 주고 받는 방식 (요청 -> 응답 -> 연결 해제)
    연결을 해제한다면 새로 요청했을 때 동일한 클라이언트인지 구분(인증)을 어떻게 하나?
    즉 어떻게 세션을 유지해야 하나?
    시큐리티를 사용하면서 어떻게 세션을 유지할 수 있는지가 가장 중요함

MIME 타입이란?
HTTP 통신은 패킷스위칭, 서킷스위칭 2가지 존재
웹 서버는 패킷 스위칭을 사용하는데, 패킷이 순서대로 도착하지 않기 때문에 모든 패킷에는 헤더가 존재한다.
헤더에 조립 순서, 출발지, 목적지, 바디 데이터 타입 등의 정보가 담김
바디에 실어 보낼 데이터가 무엇인지 적어야 하는데 기재 방식이 정해져있음 => MIME 타입
즉, 클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘이다.


** Maven이란? **

** 스프링 부트에서 jsp 사용하기 **
1. jasper 의존성 추가
2. yml에서 뷰 경로 설정
3. resources/static이 아닌 webapp/WEB-INF/views 폴더 생성하여 여기에 jsp파일 저장

** Json 왜? 어떻게? 사용하는지 **
Java에서 Python으로 데이터를 주고 받을 수는 없다. -> 공용어(Json)를 사용해서 해결
전송시 -> 자신의 언어를 Json으로 번역
응답시 -> Json을 자신의 언어로 번역
즉, Json은 중간데이터 역할
통신할 때 자바 오브젝트를 Json으로 바꾼 다는 것은 전송을 한다는 의미
HTML에서는 데이터를 Json으로 변경해서 Java로 전송하고, Java에서는 Json 데이터를 Java Object로 변경해서 받으면 된다.
-> 컨트롤러에서 req 요청이 올 때 Body 데이터를 Json으로 받음 (MIME타입 JSON)
-> 컨트롤러에서 res 할 때 Java Object를 Json으로 변경해서 응답


** dummyControllerTest detail() 변경 예정 부분 **
추후 Spring aop를 이용해서 Exception을 가로채서 에러페이지를 보여주도록 수정하기

** MessageConverter란? **
무슨 역할을, 언제 작동하는지 알아두기

** 영속성 컨텍스트 **
영속화: 1차 캐시에 객체가 들어간 상태
flush: 영속화된 객체를 DB에 넣는 것
       단, 1차 캐시를 비우지 않음(중요) -> 왜냐하면 동일 객체를 추후 select 한다면 DB 접속이 아닌 1차 캐시에서 가져올 수 있는 등 이점
컨트롤러의 메서드 위의 @Transactional를 사용하면 메서드 종료 직전에 자동 commit 실행
    -> 객체를 영속화 시킨 후 값을 변경하면 트랜잭션 종료 시점에 변경 감지
    -> 즉, 1차 캐시에 있는 객체에 변경이 있는지 체크해서 DB에 update 수행(이것을 '더티 채킹'이라 한다.)


** GlobalExceptionhandler @ControllerAdvice **
- Spring이 제공하는 AOP 기능 중 하나
- 공통적인 예외사항에 대해서는 별도로 @ControolerAdvice 어노테이션을 이용해서 분리

** Ajax를 사용하는 이유 2가지 **
1. 요청에 대한 응답을 html이 아닌 json data로 받음으로써 서버를 하나로 사용하기 위함
    -> html은 웹 브라우저(클라이언트)가 이해할 수 있는 파일, 그러나 클라이언트가 항상 웹 브라우저는 아님
    -> 클라이언트는 웹과 앱 2종류가 있는데, 일반적으로 웹은 서버로부터 html를 응답 받고 앱은 json 데이터를 응답 받는다.
    -> 응답이 다르면 서버를 두개 만들어야 하나? X
    -> json data를 리턴하는 서버만 만들어서 사용하면 된다. -> 그래서 ajax 통신이 등장, 대신 웹 클라이언트는 추가 작업(재요청) 필요
웹에서 동작 과정
    브라우저가 회원가입 처리 요청 -> 서버가 작업 후 결과를 뷰가 아닌 data를 리턴 -> 브라우저가 메인페이지 재요청

2. 비동기 통신을 하기 위함
순서에 상관없이 실행하는 것
콜백: 하던일을 멈추고 다시 돌아가는 것


** Service 계층이 필요한 이유 **
1. 트랜잭션 관리
2. 서비스 의미 때문
- 한 개 이상의 트랜잭션(하나의 작업 단위)을 하나로 묶어서 서비스화 시킬 수 있기 때문에 이용
- 전체가 성공하면 commit, 실패하면 rollback 처리 @Transactional




/////////////////////////////////////////////////////////

** DB 격리수준 **
- 트랜잭션: 일이 처리되기 위한 가장 작은 단위
여러개의 트랜잭션이 모여서 하나의 트랜잭션이 될 수 있다.
예를 들어 유튜브 1강을 만들기 위해 1.강의 준비(T1) 2. 영상 찍기(T2) 3. 영상 업로드(T3)을 모아서
하나의 트랜잭션으로 처리할 수 있으며, 스프링에서는 이를 service라고 한다.

- DB 격리수준이란?
오라클의 경우 Read Commit 전략이 기본
-> 즉 한 트랜잭션에서 데이터를 수정하고 커밋을 하지 않으면, 다른 트랜잭션에서 동일한 데이터를 요청할 때 수정 전 데이터로 읽어들임
    수정, 삭제 등 데이터 변경에 관한 요청이 DB에 들어오면 DB에 있는 undo영역의 데이터(수정 전 데이터)를 읽는다.
    커밋을 실행할 때 수정한 내역이 undo 영역에도 반영된다.
문제점은 중간에 다른 트랜잭션이 끼어들어서 데이터의 정합성을 보장할 수 없다.
이때 데이터가 보였다 안 보였다 하는 것을(데이터를 select 할 때 마다 값이 달라지는 현상) "Phantom Read"라고 한다.
이러한 문제를 해결하려면 repeatable read 이상 방식을 사용하면 부정합이 발생 X
http://wiki.gurubee.net/pages/viewpage.action?pageId=3900389 참고

MySQL
    -> InnoDB 스토리지 엔진
    -> Repeatable Read 방식 사용, 중간에 다른 트랜잭션이 수정하고 커밋하더라도 내가 처음에 읽어온 데이터 그대로 읽어온다.
        -> select시 자신보다 먼저 발생한 트랜잭션의 undo로그를 보고 select 수행
        -> 그래서 select도 트랜잭션이 필요하다. 동일한 데이터를 보장(정합성 유지)하기 때문
        -> 스프링에서는 @Transactional 지원, select도 되도록 붙이는 것을 추천



** 스프링의 전통적인 트랜잭션 **
요청 발생
1. DB 연결 생성
2. JDBC 커넥션 시작, 트랜잭션 시작, 영속성 컨텍스트 시작
컨트롤러 요청 분기 -> 서비스 -> 레파지토리 -> DB -> 레파지토리 -> 서비스
-> 컨트롤러로 돌아오면 3. 트랜잭션 종료(변경감지 DB에 flush) ->  JDBC 커넥션 종료
4.영속성 컨텍스트 종료
5. DB 연결 세션 종료
응답

이 방식에 문제점이 있음

JPA Open In View(default = true) 전략
요청이 들어왔을 때 영속성 시작하고
컨트롤러에서 서비스로 넘어가는 시점에 JDBC 커넥션, 트랜잭션 시작을 해도 됨
컨트롤러에서 돌아오는 시점 말고 서비스가 종료되는 시점에 커넥션, 트랜잭션, 영속성을 모두 종료 시키는 것이 DB의 부하를 줄임

-> 이렇게 했을 경우 문제점은 지연로딩인 경우 컨트롤러에서 프록시 객체를 호출할 수 없음, 영속성 컨텍스트가 종료되어버렸기 때문
-> 영속성을 프레젠테이션 계층(컨트롤러)에서 시작 및 종료, 트랜잭션, JDBC 커넥션은 서비스 계층에서 시작 및 종료
-> 트랜잭션이 종료되어도 컨트롤러의 session(영속성 컨텍스트)이 close되지 않았기 때문에,
-> 영속 객체는 영속화 상태 유지 및 프록시 객체에 대한 지연 로딩 수행이 가능하다.
-> 이 때, JDBC 커넥션만 잠깐 열어서 프록시 객체를 DB에서 실제로 조회해오는 작업만 가능함
-> 트랜잭션이 다시 시작하는 것이 아니기 때문에 영속 객체에 대해 업데이트는 수행 불가

스프링부트의 트랜잭션(Open In View = true)
- 세션의 시작은 서블릿이 시작되는 시점 부터~ (세션은 영속성 컨텍스트를 포함)
- 트랜잭션의 시작은 서비스 레이어부터, JDBC 커넥션도 이 시점부터.
- 트랜잭션의 종료는 서비스 계층에서 종료, JDBC 커넥션도 이 시점 부터 종료.
- 세션은 컨트롤러 영역까지 끌고 가기 때문에 영속성이 보장되어 select가 가능해지고 lazy-loading이 가능해진다.
- false로 변경하면 영속성 컨텍스트도 서비스 레이어에서 종료됨

- 세션이란?
일정 시간동안 같은 사용자(정확하게 브라우저를 말한다)로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술




** 스프링 시큐리티 **
로그인 요청 -> 시큐리티가 가로챔 -> 로그인 진행 -> 성공하면 시큐리티 세션에 유저정보를 넣음
이때, 세션에는 UserDetails 타입의 객체만 담을 수 있는데 User 객체를 UserDetails 상속 받도록 하면 됨(다형성)
그리고 로그인 진행 시 패스워드 정보를 해쉬 처리 해서 넘겨야 함

- XSS란?
자바스크립트 공격
네이버 lucy 라이브러리 등을 사용하면 간단하게 막을 수 있음

- CSRF란?
사용자가 서버에 공격하도록 즉 사용자가 의도하지 않은 공격을 서버에 하게 됨


** 스프링 작동 원리 **
톰켓 시작 - 필터 - 디스패처 - controller - service - repo - 영속성 - datasource - DB

톰켓이 실행되면 메모리에 미리 만들어지는 것 -> 필터, 디스패처, datasource, 뷰리졸버, 인터셉터 등
사용자 요청이 들어올때마다 메모리에 만들어지는 것 -> controller, service, jpa repo, 영속성 컨텍스트

controller(JDBC 연결) - service(트랜잭션 시작 및 종료)
트랜잭션이 종료될 때 실제로 커밋이 일어난다.


** 스프링 시큐리티 **
세션 내부에 시큐리티만을 위한 공간이 있는데 이를 시큐리티 컨텍스트라고 한다.
이 공간에는 User 객체를 저장하는 것이 아닌 Authentication 객체를 저장한다.
Authentication 객체는 AuthenticationManager가 만드는데, username, password를 알아야 한다.

-> 사용자가 로그인(username, password)
-> 필터(Authentication Filter)가 낚아채서 UsernameAuthenticationToken 생성
-> UsernameAuthenticationToken를 Manager에 던지면 Manager가 세션(Authentication 객체)을 생성해줌
-> Manager는 username을 UserDetailService에 던진다. 왜냐하면 해당 유저가 DB에 있는지 알아야 하기 때문에 UserDetailService가 DB에 질의를 수행
-> 존재하면 Manager는 password를 암호화해서 DB랑 비교 확인
-> 맞으면 Authentication 객체를 만들어서 세션에 저장

(질문) 회원 수정 컨트롤러
1. 기존에 있던 Authentication은 사라지는 건가? 덮어씌우는건가?
2. UsernamePasswordAuthenticationToken의 파라미터 값 유형이 다양한데 차이는?


세션값을 변경하는 방법 두가지
authentication을 만들어야하는데 방법이 조금 다름 UserDetailService를 거치냐 안거치냐 차이
후자는 Manager를 사용하기 때문에 UserDetailService가 DB에 username으로 질의해서 존재한다면 password를 암호화해서 DB와 비교 확인, 맞으면 객체를 세션에 담는다
즉, 자동으로 세션에 값을 담아줌 httpSession.setAttribute("SPRING_SECURITY_CONTEXT", securityContext) 과정이 필요 X

        //1. Authentication 객체를 만들어서 강제로 넣는 방법 ---> 사용X
        //회원 정보가 1000개라면? 각 필드를 수기로 수정해서 principal 값을 변경하는 것은 번거로움
//        principal.getUser().setEmail(user.getEmail());
//        principal.getUser().setPassword(user.getPassword());  //이렇게 넣어주면 암호화 되지 않은 값으로 들어감 -> 서비스 단에서 user.setPassword(encPassword) 수행해줘야함

        Authentication authentication = new UsernamePasswordAuthenticationToken(principal, null, principal.getAuthorities());
        SecurityContext securityContext = SecurityContextHolder.getContext();
        securityContext.setAuthentication(authentication);
        httpSession.setAttribute("SPRING_SECURITY_CONTEXT", securityContext); //세션 속성값 변경하는 차이점

        //2. Manager에 접근해서 강제 로그인하여 Authentication을 만들면 자동으로 시큐리티 세션에 넣어주는 방법
        //기존에 있던 Authentication은 사라지는 건가?
        //UsernamePasswordAuthenticationToken의 파라미터 값 유형이 다양한데 차이는?
        //세션 등록
        //이 방식을 사용하려면 username도 bodydata에 담아서 받아야함
        Authentication authentication =
                authenticationManager.authenticate(
                        new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword()));
        SecurityContextHolder.getContext().setAuthentication(authentication);




** 카카오 로그인 **
- 활성화 설정
- Redirect URI	(로그인 성공시 데이터를 받게 될 주소)
  http://localhost:8080/auth/kakao/callback
- Logout Redirect URI
  http://loacalhost:8080/auth/kakao/logout
- 플랫폼 web 도메인 등록
- Rest API 키 사용 (노출 X)